# 1. Setting Up TypeScript for Production

## Initializing TypeScript
To set up TypeScript in a project, we run:

    tsc --init

This command creates a `tsconfig.json` file.  
This file is used to configure all TypeScript-related settings for the project, such as target version, strictness, output directory, and more.

---

## Using TypeScript with HTML
In production, browsers do **not** understand TypeScript.  
So in `index.html`, we always point the `<script src="">` to a **JavaScript file**, not a `.ts` file.

The JavaScript file is the output generated by TypeScript after compilation.

---

## Output Directory (`outDir`)
In `tsconfig.json`, we usually specify an `outDir` (for example, `dist/`).  
TypeScript compiles `.ts` files and places the generated `.js` files into this directory.

This keeps:
- source TypeScript files separate
- compiled JavaScript files cleanly organized

---

## Watch Mode
To continuously compile TypeScript while developing, we use **watch mode**:

    tsc index.ts -w

In watch mode:
- TypeScript keeps watching the file
- Any change in `index.ts` automatically generates `index.js`
- The output JavaScript file is placed in the configured `outDir` (e.g., `dist/`)

---

## Key Idea
TypeScript is mainly a **development tool for type safety**.  
We write TypeScript during development, but the application always runs on the compiled JavaScript output.

---

## Summary
- `tsc --init` creates the TypeScript config file
- Browsers load only compiled `.js` files
- `outDir` controls where JS output is generated
- Watch mode (`-w`) recompiles automatically on changes
- Production always runs JavaScript, not TypeScript

[[2025-12-23]]

# 2. - Classes in TypeScript 

## Basic Classes
TypeScript classes are very similar to JavaScript classes, but with **type annotations** for properties and constructor parameters.

    class User {
      email: string;
      name: string;
      city?: string;

      constructor(email: string, name: string) {
        this.email = email;
        this.name = name;
      }
    }

    const akshith: User = new User("akshithg01@gmail.com", "Akshith");
    akshith.city = "Bengaluru";

    console.log(akshith);

Here:
- Class properties are explicitly typed
- Optional properties can be marked using `?`
- TypeScript ensures correct values are assigned

---

## Public and Private Access Modifiers
TypeScript introduces **access modifiers** to control visibility.

- `public` → accessible everywhere (default)
- `private` → accessible only within the class

If no modifier is specified, the property is **public by default**.

    class User {
      public email: string;
      public name: string;
      private city?: string;

      constructor(email: string, name: string) {
        this.email = email;
        this.name = name;
      }
    }

    const akshith: User = new User("akshithg01@gmail.com", "Akshith");
    akshith.city = "Bengaluru"; // ❌ Not allowed (private)

    console.log(akshith);

Here:
- `email` and `name` can be accessed freely
- `city` cannot be accessed or modified outside the class

---

## Summary
- TypeScript classes extend JavaScript classes with type safety
- Properties must be declared with types
- Access modifiers control visibility
- `public` is the default
- `private` restricts access to within the class only


[[2025-12-24]]

# 3. Getters and Setters in TypeScript

## Getters and Setters Overview
TypeScript supports **getters** and **setters** to control how class properties are accessed and modified.  
They are commonly used with **private fields** to add validation or computed logic.

Both private and public properties can be accessed through getters and setters.

---

## Important Gotcha with Setters
In TypeScript, **setters cannot return any value**.

If you try to specify a return type for a setter, TypeScript throws an error:

A `set` accessor cannot have a return type annotation.

This means:
- Setters are only for **updating values**
- They must return `void` implicitly

---

## Example

```ts
class User {
  private _courseCount: number = 1;
  public email: string;
  public name: string;
  private city?: string;

  constructor(email: string, name: string) {
    this.email = email;
    this.name = name;
  }

  set setCourseCount(courseNum: number) {
    if (courseNum <= 0) {
      throw new Error("Enter valid course count");
    }
    this._courseCount = courseNum;
  }

  get appleEmailId(): string {
    return `apple${this.email}`;
  }

  get courseCount(): number {
    return this._courseCount;
  }
}

const akshith: User = new User("akshithg01@gmail.com", "Akshith");
console.log(akshith);
```
## Key Points
- Setters **cannot** return values
- Getters **must** return a value
- Setters are ideal for validation logic
- Getters are useful for computed or derived values
- Private fields are commonly exposed via getters/setters

## Summary
- Use setters to control how values are assigned
- Use getters to safely expose or compute values
- TypeScript enforces stricter rules on setters compared to JavaScript


# 4. Protected Access Modifier in TypeScript

## Access Modifiers Recap
TypeScript provides **three access modifiers** that can be applied to both variables and methods:
- `public`
- `private`
- `protected`

If no modifier is specified, the member is **public by default**.

---

## `private`
- Accessible **only within the class where it is defined**
- **Not accessible** in child (inheriting) classes
- **Not accessible** outside the class

Example behavior:
- A `private` property cannot be used inside a subclass
- Attempting to do so will cause a TypeScript error

---

## Problem with `private` in Inheritance
In the following example, `_courseCount` is marked as `private`, so it cannot be accessed in the subclass:

    class User {
      private _courseCount: number = 1;
      public email: string;
      public name: string;

      constructor(email: string, name: string) {
        this.email = email;
        this.name = name;
      }

      set setCourseCount(courseNum: number) {
        if (courseNum <= 0) {
          throw new Error("Enter valid course count");
        }
        this._courseCount = courseNum;
      }

      get courseCount(): number {
        return this._courseCount;
      }
    }

    class SubUser extends User {
      isFamily: boolean = true;

      changeCourseCount(courseCount: number) {
        this._courseCount = courseCount; // ❌ Error: private property
      }
    }

This fails because `private` members are **not inherited**.

---

## `protected`
- Accessible **within the class**
- Accessible in **subclasses**
- **Not accessible** outside the class hierarchy

To fix the issue above, we change `private` to `protected`:

    protected _courseCount: number = 1;

Now the subclass can access `_courseCount`, but external code still cannot.

---

## Why `protected` Is Useful
- Allows controlled inheritance
- Keeps internal state hidden from outside usage
- Enables subclasses to extend behavior safely

---

## Summary
- `public` → accessible everywhere (default)
- `private` → accessible only within the same class
- `protected` → accessible within the class and its subclasses
- Use `protected` when a property should be shared with child classes but hidden from the outside



# 5. Implementing Interfaces in Classes 

In TypeScript, the `implements` keyword is used in a class declaration to ensure that the class adheres to a specific `interface`. 

- **Contract Enforcement**: An `interface` defines a "contract" that specifies the required properties and methods that a class must have. When a class uses `implements`, TypeScript checks that the class provides a concrete implementation for every member defined in that interface.
- **Abstraction and Reusability**: This mechanism promotes abstraction and code reusability by ensuring objects adhere to a predictable structure, which is a key concept in object-oriented programming.
- **Multiple Interfaces**: Unlike class inheritance (which uses `extends`, and a class can only extend one other class), a single class can implement multiple interfaces at once.

## Importance of Interfaces
Interfaces define a **contract**.  
They do **not** provide implementations — they only enforce **what properties and methods must exist**.

A class:
- **can do more** than what an interface asks for
- **cannot do less** than what the interface defines

Interfaces ensure consistency while still allowing flexibility.

---

## Basic Interface Implementation
When a class implements an interface, it must define **all the required fields**.

    interface TakePhoto {
      cameraMode: string;
      filter: string;
      burst: number;
    }

    class Instagram implements TakePhoto {
      constructor(
        public cameraMode: string,
        public filter: string,
        public burst: number
      ) {}
    }

Here, the class must contain everything defined in `TakePhoto`.

---

## Extra Properties Are Allowed
A class can add **extra fields** beyond what the interface defines.

    class Youtube implements TakePhoto {
      constructor(
        public cameraMode: string,
        public filter: string,
        public burst: number,
        public short: string
      ) {}
    }

This is valid because the required interface fields are still present.

---

## Implementing Multiple Interfaces
A class can implement **more than one interface**.

    interface TakePhoto {
      filter: string;
      short: string;
      burst: number;
    }

    interface Story {
      createStory: () => void;
    }

    class Instagram implements TakePhoto, Story {
      constructor(
        public filter: string,
        public short: string,
        public burst: number
      ) {}

      public createStory(): void {
        console.log("Created story");
      }
    }

Here:
- `Instagram` must satisfy **both** interfaces
- All required properties and methods must be implemented

---

## Key Rules
- Interfaces enforce structure, not implementation
- Classes can implement **multiple interfaces**
- Classes may add extra properties or methods
- Missing required members causes TypeScript errors

---

## Summary
- Interfaces define what a class **must have**
- Classes can extend behavior beyond interfaces
- Multiple interfaces can be implemented together
- Interfaces are essential for scalable, consistent design
